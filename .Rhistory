gc()
rm(list = ls(all = TRUE))
if(!require(ggplot2)) install.packages("ggplot2") else library(ggplot2)
if(!require(ggalt)) install.packages("ggalt") else library(ggalt)
if(!require(dplyr)) install.packages("dplyr") else library(dplyr)
if(!require(tidyverse)) install.packages("tidyverse") else library(tidyverse)
if(!require(gridExtra)) install.packages("gridExtra") else library(gridExtra)
if(!require(grid)) install.packages("grid") else library(grid)
if(!require(xlsx)) install.packages("xlsx") else library(xlsx)
if(!require(openxlsx)) install.packages("openxlsx") else library(openxlsx)
if(!require(corrplot)) install.packages("corrplot") else library(corrplot)
if(!require(kableExtra)) install.packages("kableExtra") else library(kableExtra)
if(!require(psych)) install.packages("psych") else library(psych)
if(!require(mvShapiroTest)) install.packages("mvShapiroTest") else library(mvShapiroTest)
if(!require(MVar.pt)) install.packages(MVar.pt) else library(MVar.pt)
if(!require(kableExtra)) install.packages("kableExtra") else library(kableExtra)
if(!require(ppclust)) install.packages("ppclust") else library("ppclust")
if(!require(NbClust)) install.packages("NbClust") else library("NbClust")
if(!require(packHV)) install.packages("packHV") else library(packHV)
if(!require(readxl)) install.packages("reaxl") else library(readxl)
if(!require(MASS)) install.packages("MASS") else library(MASS)
if(!require(exploreR)) install.packages("exploreR") else library(exploreR)
if(!require(Hmisc)) install.packages("misc") else library(Hmisc)
if(!require(moments)) install.packages(moments) else require(moments)
if(!require(openxlsx)) install.packages(openxlsx) else require(openxlsx)
if(!require(nortest)) install.packages(nortest) else require(nortest)
if(!require(lmtest)) install.packages(lmtest) else require(lmtest)
if(!require(forecast)) install.packages(forecast) else require(forecast)
if(!require(lubridate)) install.packages(lubridate) else library(lubridate)
#library(xlsx)
if(!require(RColorBrewer)) install.packages("RColorBrewer") else library(RColorBrewer)
#library(rcompanion)
require(ggpubr)
if(!require(rbcb)) install.packages("rbcb") else library(rbcb)
if(!require(qqplotr)) install.packages("qqplotr") else library(qqplotr)
if(!require(car)) install.packages("car") else library(car)
if(!require(pROC)) install.packages("pROC") else library(pROC)
if(!require(mlogit)) install.packages("mlogit") else library(mlogit)
if(!require(readr)) install.packages("readr") else library(readr)
if(!require(rpart)) install.packages("rpart") else library(rpart)
if(!require(rpart.plot)) install.packages("rpart.plot") else library(rpart.plot)
if(!require(randomForest)) install.packages("randomForest") else library(randomForest)
if(!require(lpSolve)) install.packages("lpSolve") else library (lpSolve)
###  Windows
library(readxl)
dados <- read_excel("BaseCompilada_TS14_2022.xlsx",
sheet = "DadosEscores")
### Estatísticas - resumo
summary(dados)
### Transformação do IdAgente as char
dados$IdAgente = as.character(dados$IdAgente)
### dataset com variáveis do modelo
db = with(dados,dplyr::select(dados, Concessionaria, Tipo,
Ano, PMSO, rede.menor.230,
rede.maior.230,MVA,Mvar,
modulos.sub.menor230,modulos.sub.maior230,
modulos.manobra.menor230,modulos.manobra.maior230))
### Modificacao dos nomes das variaveis
names(db)[5]  = "X1"
names(db)[6]  = "X2"
names(db)[7]  = "X3"
names(db)[8]  = "X4"
names(db)[9]  = "X5"
names(db)[10] = "X6"
names(db)[11] = "X7"
names(db)[12] = "X8"
### Histograma
with(db,packHV::hist_boxplot(PMSO, main="Histograma",
col="light blue",
xlab="PMSO"))
### Scatter plots
#par(mfrow=c(4,2))
plot(PMSO ~ X1, data=db, pch=19, col="dark blue", main =  ""); title(main = "PMSO x X1")
plot(PMSO ~ X2, data=db, pch=19, col="red", main =""); title(main = "PMSO x X2")
plot(PMSO ~ X3, data=db, pch=19, col="green", main =""); title(main = "PMSO x X3")
plot(PMSO ~ X4, data=db, pch=19, col="cyan", main =""); title(main = "PMSO x X4")
plot(PMSO ~ X5, data=db, pch=19, col="grey",main =""); title(main = "PMSO x X5")
plot(PMSO ~ X6, data=db, pch=19, col="orange",main =""); title(main = "PMSO x X6")
plot(PMSO ~ X7, data=db, pch=19, col="purple", main =""); title(main = "PMSO x X7")
plot(PMSO ~ X8, data=db, pch=19, col="black",main =""); title(main = "PMSO x X8")
### Correlation plots
dbcor = with(db,dplyr::select(db, PMSO,X1,X2,X3,X4,X5,X6,X7,X8))
matCor <- cor(dbcor, method="spearman")
corrplot(matCor, type="upper",
order="AOE", diag=FALSE, addgrid.col=NA,
outline=TRUE)
with(db,
boxplot(PMSO ~ Ano,
main="PMSO anual",
col="dark blue",
xlab="Ano",
ylab="PMSO")
)
with(db,
boxplot(PMSO ~ Concessionaria,
main="PMSO por conc.",
col="green",
xlab="Conc.",
ylab="PMSO")
)
with(db,
boxplot(PMSO ~ Tipo,
main="PMSO por tipo",
col="orange",
xlab="Tipo",
ylab="PMSO")
)
### Analisando o R2 de cada variavel separadamente
exploreR::masslm(dbcor,"PMSO")
### modelo linear múltiplo com todas as variaveis
modelo = lm(PMSO ~ ., data=dbcor)
summary(modelo)
plot(modelo, lty=0, pch=19, col="blue")
x1 = db$X1
x2 = db$X2
x3 = db$X3
x4 = db$X4
x5 = db$X5
x6 = db$X6
x7 = db$X7
x8 = db$X8
N = nrow(db)
tau = 0.5
### (tau*e1,tau*e2,alfa1,alfa2,x1,x2  )
f.obj = c(rep(tau,N), rep(1-tau,N),0
# ,0
# ,0
# ,0
# ,0
# ,0
# ,0
# ,0
# ,0
# ,0
)
f.con = NULL
for(cont in 1:nrow(db)){
e1 = rep(0, nrow(db)) # Inicializacao do vetor de erro (positivo)
e2 = rep(0, nrow(db)) # Inicializacao do vetor de erro (negativo)
### Atribuição dos coeficientes
e1[cont] = +1
e2[cont] = -1
### f.aux -> atribuição dos coeficientes de xi
f.aux <- c(e1, e2, +1, -1, x1[cont]
# ,x2[cont]
# ,x3[cont]
# ,x4[cont]
# ,x5[cont]
# ,x6[cont]
# ,x7[cont]
# ,x8[cont]
)
f.con <- rbind(f.con, f.aux)
}
View(f.con)
f.dir = rep("=", N)
f.rhs = y
f.rhs = y
y = db$PMSO
### Gera a solucao
saida   = lpSolve::lp ("min", f.obj, f.con, f.dir, f.rhs)
f.con = NULL
for(cont in 1:nrow(db)){
e1 = rep(0, nrow(db)) # Inicializacao do vetor de erro (positivo)
e2 = rep(0, nrow(db)) # Inicializacao do vetor de erro (negativo)
### Atribuição dos coeficientes
e1[cont] = +1
e2[cont] = -1
### f.aux -> atribuição dos coeficientes de xi
f.aux <- c(e1, e2, +1, -1, x1[cont]
# ,x2[cont]
# ,x3[cont]
# ,x4[cont]
# ,x5[cont]
# ,x6[cont]
# ,x7[cont]
# ,x8[cont]
)
f.con <- rbind(f.con, f.aux)
}
# View(f.con)
f.dir = rep("=", N)
f.rhs = y
### Gera a solucao
saida   = lpSolve::lp ("min", f.obj, f.con, f.dir, f.rhs)
solucao = saida$solution
### Para algumas componentes: erro e intercepto existem as
### 'partes' positivas e negativas. Entao, o valor final eh a
### diferenca entre essas partes.
erros <- solucao[1:N] - solucao[(N+1):(2*N)]
alpha <- solucao[(2*N)+1] - solucao[(2*N)+2]
beta1 <- solucao[(2*N)+3]
plot(PMSO ~ X1, data=db, pch=19, col="blue")
# plot(PMSO ~ X2, data=db, pch=19, col="blue")
# plot(PMSO ~ X3, data=db, pch=19, col="blue")
# plot(PMSO ~ X4, data=db, pch=19, col="blue")
# plot(PMSO ~ X5, data=db, pch=19, col="blue")
# plot(PMSO ~ X6, data=db, pch=19, col="blue")
# plot(PMSO ~ X7, data=db, pch=19, col="blue")
# plot(PMSO ~ X8, data=db, pch=19, col="blue")
abline(a=alpha, b=beta, lwd=2, col="black")
rm(list = ls(all = TRUE))
if(!require(ggplot2)) install.packages("ggplot2") else library(ggplot2)
if(!require(ggalt)) install.packages("ggalt") else library(ggalt)
if(!require(dplyr)) install.packages("dplyr") else library(dplyr)
if(!require(tidyverse)) install.packages("tidyverse") else library(tidyverse)
if(!require(gridExtra)) install.packages("gridExtra") else library(gridExtra)
if(!require(grid)) install.packages("grid") else library(grid)
if(!require(xlsx)) install.packages("xlsx") else library(xlsx)
if(!require(openxlsx)) install.packages("openxlsx") else library(openxlsx)
if(!require(corrplot)) install.packages("corrplot") else library(corrplot)
if(!require(kableExtra)) install.packages("kableExtra") else library(kableExtra)
if(!require(psych)) install.packages("psych") else library(psych)
if(!require(mvShapiroTest)) install.packages("mvShapiroTest") else library(mvShapiroTest)
if(!require(MVar.pt)) install.packages(MVar.pt) else library(MVar.pt)
if(!require(kableExtra)) install.packages("kableExtra") else library(kableExtra)
if(!require(ppclust)) install.packages("ppclust") else library("ppclust")
if(!require(NbClust)) install.packages("NbClust") else library("NbClust")
if(!require(packHV)) install.packages("packHV") else library(packHV)
if(!require(readxl)) install.packages("reaxl") else library(readxl)
if(!require(MASS)) install.packages("MASS") else library(MASS)
if(!require(exploreR)) install.packages("exploreR") else library(exploreR)
if(!require(Hmisc)) install.packages("misc") else library(Hmisc)
if(!require(moments)) install.packages(moments) else require(moments)
if(!require(openxlsx)) install.packages(openxlsx) else require(openxlsx)
if(!require(nortest)) install.packages(nortest) else require(nortest)
if(!require(lmtest)) install.packages(lmtest) else require(lmtest)
if(!require(forecast)) install.packages(forecast) else require(forecast)
if(!require(lubridate)) install.packages(lubridate) else library(lubridate)
#library(xlsx)
if(!require(RColorBrewer)) install.packages("RColorBrewer") else library(RColorBrewer)
#library(rcompanion)
require(ggpubr)
if(!require(rbcb)) install.packages("rbcb") else library(rbcb)
if(!require(qqplotr)) install.packages("qqplotr") else library(qqplotr)
if(!require(car)) install.packages("car") else library(car)
if(!require(pROC)) install.packages("pROC") else library(pROC)
if(!require(mlogit)) install.packages("mlogit") else library(mlogit)
if(!require(readr)) install.packages("readr") else library(readr)
if(!require(rpart)) install.packages("rpart") else library(rpart)
if(!require(rpart.plot)) install.packages("rpart.plot") else library(rpart.plot)
if(!require(randomForest)) install.packages("randomForest") else library(randomForest)
if(!require(lpSolve)) install.packages("lpSolve") else library (lpSolve)
### MacOS
dados =  read_excel("~/Library/CloudStorage/OneDrive-Pessoal/Documentos/7. Especialização/3. TCC/3. Códigos/tcc/BaseCompilada_TS14_2022.xlsx",
sheet = "DadosEscores")
###  Windows
library(readxl)
dados <- read_excel("BaseCompilada_TS14_2022.xlsx",
sheet = "DadosEscores")
### Estatísticas - resumo
summary(dados)
### Transformação do IdAgente as char
dados$IdAgente = as.character(dados$IdAgente)
### dataset com variáveis do modelo
db = with(dados,dplyr::select(dados, Concessionaria, Tipo,
Ano, PMSO, rede.menor.230,
rede.maior.230,MVA,Mvar,
modulos.sub.menor230,modulos.sub.maior230,
modulos.manobra.menor230,modulos.manobra.maior230))
### Modificacao dos nomes das variaveis
names(db)[5]  = "X1"
names(db)[6]  = "X2"
names(db)[7]  = "X3"
names(db)[8]  = "X4"
names(db)[9]  = "X5"
names(db)[10] = "X6"
names(db)[11] = "X7"
names(db)[12] = "X8"
### Histograma
with(db,packHV::hist_boxplot(PMSO, main="Histograma",
col="light blue",
xlab="PMSO"))
### Scatter plots
#par(mfrow=c(4,2))
plot(PMSO ~ X1, data=db, pch=19, col="dark blue", main =  ""); title(main = "PMSO x X1")
### Modificacao dos nomes das variaveis
names(db)[5]  = "X1"
names(db)[6]  = "X2"
names(db)[7]  = "X3"
names(db)[8]  = "X4"
names(db)[9]  = "X5"
names(db)[10] = "X6"
names(db)[11] = "X7"
names(db)[12] = "X8"
### Histograma
with(db,packHV::hist_boxplot(PMSO, main="Histograma",
col="light blue",
xlab="PMSO"))
### Scatter plots
#par(mfrow=c(4,2))
plot(PMSO ~ X1, data=db, pch=19, col="dark blue", main =  ""); title(main = "PMSO x X1")
plot(PMSO ~ X2, data=db, pch=19, col="red", main =""); title(main = "PMSO x X2")
plot(PMSO ~ X3, data=db, pch=19, col="green", main =""); title(main = "PMSO x X3")
plot(PMSO ~ X4, data=db, pch=19, col="cyan", main =""); title(main = "PMSO x X4")
plot(PMSO ~ X5, data=db, pch=19, col="grey",main =""); title(main = "PMSO x X5")
plot(PMSO ~ X6, data=db, pch=19, col="orange",main =""); title(main = "PMSO x X6")
plot(PMSO ~ X7, data=db, pch=19, col="purple", main =""); title(main = "PMSO x X7")
plot(PMSO ~ X8, data=db, pch=19, col="black",main =""); title(main = "PMSO x X8")
### Correlation plots
dbcor = with(db,dplyr::select(db, PMSO,X1,X2,X3,X4,X5,X6,X7,X8))
matCor <- cor(dbcor, method="spearman")
corrplot(matCor, type="upper",
order="AOE", diag=FALSE, addgrid.col=NA,
outline=TRUE)
with(db,
boxplot(PMSO ~ Ano,
main="PMSO anual",
col="dark blue",
xlab="Ano",
ylab="PMSO")
)
with(db,
boxplot(PMSO ~ Concessionaria,
main="PMSO por conc.",
col="green",
xlab="Conc.",
ylab="PMSO")
)
with(db,
boxplot(PMSO ~ Tipo,
main="PMSO por tipo",
col="orange",
xlab="Tipo",
ylab="PMSO")
)
### Analisando o R2 de cada variavel separadamente
exploreR::masslm(dbcor,"PMSO")
### modelo linear múltiplo com todas as variaveis
modelo = lm(PMSO ~ ., data=dbcor)
summary(modelo)
plot(modelo, lty=0, pch=19, col="blue")
x1 = db$X1
x2 = db$X2
x3 = db$X3
x4 = db$X4
x5 = db$X5
x6 = db$X6
x7 = db$X7
x8 = db$X8
N = nrow(db)
tau = 0.5
### (tau*e1,tau*e2,alfa1,alfa2,x1,x2  )
f.obj = c(rep(tau,N), rep(1-tau,N),0
# ,0
# ,0
# ,0
# ,0
# ,0
# ,0
# ,0
# ,0
# ,0
)
f.con = NULL
for(cont in 1:nrow(db)){
e1 = rep(0, nrow(db)) # Inicializacao do vetor de erro (positivo)
e2 = rep(0, nrow(db)) # Inicializacao do vetor de erro (negativo)
### Atribuição dos coeficientes
e1[cont] = +1
e2[cont] = -1
### f.aux -> atribuição dos coeficientes de xi
f.aux <- c(e1, e2, +1, -1, x1[cont]
# ,x2[cont]
# ,x3[cont]
# ,x4[cont]
# ,x5[cont]
# ,x6[cont]
# ,x7[cont]
# ,x8[cont]
)
f.con <- rbind(f.con, f.aux)
}
f.dir = rep("=", N)
f.rhs = y
y = db$PMSO
f.con = NULL
for(cont in 1:nrow(db)){
e1 = rep(0, nrow(db)) # Inicializacao do vetor de erro (positivo)
e2 = rep(0, nrow(db)) # Inicializacao do vetor de erro (negativo)
### Atribuição dos coeficientes
e1[cont] = +1
e2[cont] = -1
### f.aux -> atribuição dos coeficientes de xi
f.aux <- c(e1, e2, +1, -1, x1[cont]
# ,x2[cont]
# ,x3[cont]
# ,x4[cont]
# ,x5[cont]
# ,x6[cont]
# ,x7[cont]
# ,x8[cont]
)
f.con <- rbind(f.con, f.aux)
}
f.dir = rep("=", N)
f.rhs = y
### Gera a solucao
saida   = lpSolve::lp ("min", f.obj, f.con, f.dir, f.rhs)
solucao = saida$solution
### Para algumas componentes: erro e intercepto existem as
### 'partes' positivas e negativas. Entao, o valor final eh a
### diferenca entre essas partes.
erros <- solucao[1:N] - solucao[(N+1):(2*N)]
alpha <- solucao[(2*N)+1] - solucao[(2*N)+2]
beta1 <- solucao[(2*N)+3]
### (tau*e1,tau*e2,alfa1,alfa2,x1,x2  )
f.obj = c(rep(tau,N), rep(1-tau,N),0,0
,0
# ,0
# ,0
# ,0
# ,0
# ,0
# ,0
# ,0
)
f.con = NULL
for(cont in 1:nrow(db)){
e1 = rep(0, nrow(db)) # Inicializacao do vetor de erro (positivo)
e2 = rep(0, nrow(db)) # Inicializacao do vetor de erro (negativo)
### Atribuição dos coeficientes
e1[cont] = +1
e2[cont] = -1
### f.aux -> atribuição dos coeficientes de xi
f.aux <- c(e1, e2, +1, -1, x1[cont]
# ,x2[cont]
# ,x3[cont]
# ,x4[cont]
# ,x5[cont]
# ,x6[cont]
# ,x7[cont]
# ,x8[cont]
)
f.con <- rbind(f.con, f.aux)
}
f.dir = rep("=", N)
f.rhs = y
### Gera a solucao
saida   = lpSolve::lp ("min", f.obj, f.con, f.dir, f.rhs)
solucao = saida$solution
### Para algumas componentes: erro e intercepto existem as
### 'partes' positivas e negativas. Entao, o valor final eh a
### diferenca entre essas partes.
erros <- solucao[1:N] - solucao[(N+1):(2*N)]
alpha <- solucao[(2*N)+1] - solucao[(2*N)+2]
beta1 <- solucao[(2*N)+3]
plot(PMSO ~ X1, data=db, pch=19, col="blue")
# plot(PMSO ~ X2, data=db, pch=19, col="blue")
# plot(PMSO ~ X3, data=db, pch=19, col="blue")
# plot(PMSO ~ X4, data=db, pch=19, col="blue")
# plot(PMSO ~ X5, data=db, pch=19, col="blue")
# plot(PMSO ~ X6, data=db, pch=19, col="blue")
# plot(PMSO ~ X7, data=db, pch=19, col="blue")
# plot(PMSO ~ X8, data=db, pch=19, col="blue")
abline(a=alpha, b=beta, lwd=2, col="black")
plot(PMSO ~ X1, data=db, pch=19, col="blue")
# plot(PMSO ~ X2, data=db, pch=19, col="blue")
# plot(PMSO ~ X3, data=db, pch=19, col="blue")
# plot(PMSO ~ X4, data=db, pch=19, col="blue")
# plot(PMSO ~ X5, data=db, pch=19, col="blue")
# plot(PMSO ~ X6, data=db, pch=19, col="blue")
# plot(PMSO ~ X7, data=db, pch=19, col="blue")
# plot(PMSO ~ X8, data=db, pch=19, col="blue")
abline(a=alpha, b=beta, lwd=2, col="black")
# plot(PMSO ~ X2, data=db, pch=19, col="blue")
# plot(PMSO ~ X3, data=db, pch=19, col="blue")
# plot(PMSO ~ X4, data=db, pch=19, col="blue")
# plot(PMSO ~ X5, data=db, pch=19, col="blue")
# plot(PMSO ~ X6, data=db, pch=19, col="blue")
# plot(PMSO ~ X7, data=db, pch=19, col="blue")
# plot(PMSO ~ X8, data=db, pch=19, col="blue")
abline(a=alpha, b=beta1, lwd=2, col="black")
f.con = NULL
for(cont in 1:nrow(db)){
e1 = rep(0, nrow(db)) # Inicializacao do vetor de erro (positivo)
e2 = rep(0, nrow(db)) # Inicializacao do vetor de erro (negativo)
### Atribuição dos coeficientes
e1[cont] = +1
e2[cont] = -1
### f.aux -> atribuição dos coeficientes de xi
f.aux <- c(e1, e2, +1, -1, x2[cont]
# ,x2[cont]
# ,x3[cont]
# ,x4[cont]
# ,x5[cont]
# ,x6[cont]
# ,x7[cont]
# ,x8[cont]
)
f.con <- rbind(f.con, f.aux)
}
f.dir = rep("=", N)
f.rhs = y
### Gera a solucao
saida   = lpSolve::lp ("min", f.obj, f.con, f.dir, f.rhs)
solucao = saida$solution
### Para algumas componentes: erro e intercepto existem as
### 'partes' positivas e negativas. Entao, o valor final eh a
### diferenca entre essas partes.
erros <- solucao[1:N] - solucao[(N+1):(2*N)]
alpha <- solucao[(2*N)+1] - solucao[(2*N)+2]
beta1 <- solucao[(2*N)+3]
plot(PMSO ~ X2, data=db, pch=19, col="blue")
# plot(PMSO ~ X2, data=db, pch=19, col="blue")
# plot(PMSO ~ X3, data=db, pch=19, col="blue")
# plot(PMSO ~ X4, data=db, pch=19, col="blue")
# plot(PMSO ~ X5, data=db, pch=19, col="blue")
# plot(PMSO ~ X6, data=db, pch=19, col="blue")
# plot(PMSO ~ X7, data=db, pch=19, col="blue")
# plot(PMSO ~ X8, data=db, pch=19, col="blue")
abline(a=alpha, b=beta1, lwd=2, col="black")
